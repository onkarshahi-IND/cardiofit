const { ApolloServer } = require('@apollo/server');
const { expressMiddleware } = require('@apollo/server/express4');
const { ApolloGateway, IntrospectAndCompose } = require('@apollo/gateway');
const { gql } = require('graphql-tag');
const express = require('express');
const patientResolvers = require('./resolvers/patient-resolvers');
const http = require('http');
const cors = require('cors');
const { json } = require('body-parser');
const fs = require('fs');
const path = require('path');
const { createEvidenceEnvelopePlugin } = require('./plugins/evidence-envelope');
require('dotenv').config();

// Configure fetch with proper error handling
const fetch = (...args) => import('node-fetch').then(({default: fetch}) => fetch(...args));

// Configure logging
const logger = {
  info: (message) => console.log(`[INFO] ${new Date().toISOString()} - ${message}`),
  error: (message, error) => console.error(`[ERROR] ${new Date().toISOString()} - ${message}`, error?.message || error),
  warn: (message) => console.warn(`[WARN] ${new Date().toISOString()} - ${message}`),
  debug: (message) => console.debug(`[DEBUG] ${new Date().toISOString()} - ${message}`)
};

// Load the supergraph schema generated by Rover
const supergraphPath = path.join(__dirname, 'supergraph.graphql');

async function loadSupergraphSdl() {
  try {
    // Skip Rover execution and just read the existing supergraph file
    logger.info('[DEBUG] Reading existing supergraph.graphql file...');
    const sdl = fs.readFileSync(supergraphPath, 'utf-8');
    if (!sdl.trim()) {
      logger.error('[DEBUG] Supergraph schema file is empty.');
      throw new Error('Supergraph schema is empty');
    }
    logger.info('[DEBUG] Supergraph schema read successfully.');
    return sdl;

  } catch (error) {
    logger.error('Error loading supergraph schema:', error.message);
    throw error;
  }
}

// Function to verify service health
async function checkServiceHealth(service) {
  try {
    const response = await fetch(service.url, {
      method: 'GET',
      timeout: 5000
    }).catch(error => {
      logger.warn(`Service ${service.name} health check failed: ${error.message}`);
      return { ok: false };
    });

    if (response.ok) {
      logger.info(`Service ${service.name} is reachable`);
      return true;
    } else {
      logger.warn(`Service ${service.name} is not reachable`);
      return false;
    }
  } catch (error) {
    logger.warn(`Service ${service.name} health check failed: ${error.message}`);
    return false;
  }
}

// Import required modules
const { buildSubgraphSchema } = require('@apollo/subgraph');

// Removed static schema - using only federation composition




// Static schema parsing removed - using only federation composition

// Old service list removed - using service list in initializeGateway function

let gateway;

// Create a service builder function
function buildService({ name, url }) {
  return {
    async process({ request, context }) {
      // Log the incoming request
      logger.info(`Processing request to ${name} service at ${url}`);
      logger.debug('Request details:', {
        query: request.query,
        variables: request.variables,
        operationName: request.operationName
      });

      const headers = {
        'Content-Type': 'application/json',
        ...(context?.token && { 'Authorization': context.token }),
        ...(context?.userId && { 'X-User-ID': context.userId }),
        ...(context?.userRole && { 'X-User-Role': context.userRole }),
        ...(context?.userRoles && {
          'X-User-Roles': Array.isArray(context.userRoles)
            ? context.userRoles.join(',')
            : context.userRoles
        }),
        ...(context?.userPermissions && {
          'X-User-Permissions': Array.isArray(context.userPermissions)
            ? context.userPermissions.join(',')
            : context.userPermissions
        })
      };

      logger.debug(`Sending request to ${url} with headers:`, headers);

      try {
        const requestBody = {
          query: request.query,
          variables: request.variables || {},
          operationName: request.operationName || null
        };

        logger.debug('Request body:', JSON.stringify(requestBody, null, 2));

        const response = await fetch(url, {
          method: 'POST',
          headers,
          body: JSON.stringify(requestBody)
        });

        const responseBody = await response.text();

        if (!response.ok) {
          logger.error(`Error from ${name} service (${response.status}):`, responseBody);
          throw new Error(`HTTP error! status: ${response.status}, body: ${responseBody}`);
        }

        logger.debug(`Response from ${name} service:`, responseBody);
        return JSON.parse(responseBody);
      } catch (error) {
        logger.error(`Error calling ${name} service at ${url}:`, error);
        throw error;
      }
    }
  };
}

async function initializeGateway() {
  try {
    // Use IntrospectAndCompose for proper federation schema composition
    logger.info('Initializing Apollo Federation Gateway with IntrospectAndCompose');

    // Include all services with federation endpoints - CORRECTED MAPPINGS
    const federationServices = [
      { name: 'patients', url: 'http://localhost:8003/api/federation' },
      { name: 'medications', url: 'http://localhost:8004/api/federation' },
      { name: 'workflows', url: 'http://localhost:8015/api/federation' }, // Strategic Orchestrator
      { name: 'context-gateway', url: 'http://localhost:8117/api/federation' }, // Go Context Gateway
      { name: 'clinical-data-hub', url: 'http://localhost:8118/api/federation' }, // Rust Clinical Data Hub
      { name: 'kb1-drug-rules', url: 'http://localhost:8081/api/federation' },
      { name: 'kb2-clinical-context', url: 'http://localhost:8082/api/federation' },
      { name: 'kb3-guidelines', url: 'http://localhost:8084/graphql' },
      { name: 'kb4-patient-safety', url: 'http://localhost:8085/api/federation' },
      { name: 'kb5-ddi', url: 'http://localhost:8086/api/federation' },
      { name: 'kb6-formulary', url: 'http://localhost:8087/api/federation' },
      { name: 'kb7-terminology', url: 'http://localhost:8088/api/federation' },
      { name: 'evidence-envelope', url: 'http://localhost:8089/api/federation' }
    ];

    // Use IntrospectAndCompose for proper federation schema composition
    return new ApolloGateway({
      supergraphSdl: new IntrospectAndCompose({
        subgraphs: federationServices,
      }),
      debug: true,
      buildService
    });
  } catch (error) {
    logger.error('Failed to initialize Apollo Gateway:', error);
    throw error;
  }
}

// Start the server
const startServer = async () => {
  try {
    const app = express();
    const httpServer = http.createServer(app);

    // Set up CORS
    app.use(cors());

    // Parse JSON bodies
    app.use(express.json());

    // Health check endpoint
    app.get('/health', (req, res) => {
      res.status(200).json({ status: 'ok' });
    });

    // Initialize the Apollo Gateway with supergraph schema
    gateway = await initializeGateway();

    // Create Evidence Envelope plugin
    const evidenceEnvelopePlugin = createEvidenceEnvelopePlugin({
      evidenceServiceUrl: 'http://localhost:8088/graphql',
      enableLogging: true,
      logger: logger
    });

    // Create Apollo Server with the gateway and Evidence Envelope plugin
    const server = new ApolloServer({
      gateway,
      // Enable schema introspection in all environments
      introspection: true,
      // Enable query logging
      debug: true,
      // Add Evidence Envelope plugin for audit trails
      plugins: [evidenceEnvelopePlugin],
      // Set up error handling
      formatError: (err) => {
        logger.error('GraphQL Error:', err);
        return err;
      },
    });

    // Start the server
    await server.start();

    // Helper function to safely parse headers
    const parseHeader = (header, defaultValue = null) => {
      if (!header) return defaultValue;
      try {
        // If it's already an array/object, return as is
        if (Array.isArray(header) || typeof header === 'object') return header;
        // If it's a string that looks like a JSON array/object, parse it
        if (typeof header === 'string' && (header.startsWith('[') || header.startsWith('{'))) {
          return JSON.parse(header);
        }
        // If it's a comma-separated string, split it
        if (typeof header === 'string' && header.includes(',')) {
          return header.split(',').map(item => item.trim());
        }
        // Otherwise return as is or as array with single item
        return header.includes(',') ? header.split(',').map(item => item.trim()) : [header];
      } catch (error) {
        logger.error('Error parsing header:', { header, error: error.message });
        return defaultValue;
      }
    };

    // Create the GraphQL middleware with context
    const graphqlMiddleware = expressMiddleware(server, {
      context: async ({ req }) => {
        const context = {
          token: req.headers.authorization || '',
          userId: req.headers['x-user-id'],
          userEmail: req.headers['x-user-email'],
          userName: req.headers['x-user-name'],
          // Handle user role (single value)
          userRole: req.headers['x-user-role'],
          // Handle user roles (array)
          userRoles: parseHeader(req.headers['x-user-roles'], []),
          // Handle user permissions (array)
          userPermissions: parseHeader(req.headers['x-user-permissions'], []),
          // Include raw headers for debugging
          _headers: req.headers
        };
        
        logger.debug('GraphQL context created:', {
          userId: context.userId,
          userRole: context.userRole,
          userRoles: context.userRoles,
          permissions: context.userPermissions
        });
        
        return context;
      },
    });

    // Set up GraphQL endpoints
    app.use('/graphql', cors(), json(), graphqlMiddleware);
    // Add API Gateway compatible endpoint
    app.use('/api/graphql', cors(), json(), graphqlMiddleware);

    // Add health check endpoints
    app.get('/health', (req, res) => {
      res.json({ status: 'ok' });
    });
    app.get('/api/health', (req, res) => {
      res.json({ status: 'ok' });
    });

    // Start the HTTP server
    const PORT = process.env.PORT || 4000;
    await new Promise((resolve) => httpServer.listen({ port: PORT }, resolve));
    logger.info(`ðŸš€ Server ready at http://localhost:${PORT}/graphql`);
    logger.info(`ðŸš€ Health check available at http://localhost:${PORT}/health`);

    // Handle shutdown gracefully
    const shutdown = async () => {
      logger.info('Shutting down server...');
      await server.stop();
      httpServer.close(() => {
        logger.info('Server has been shut down');
        process.exit(0);
      });
    };

    process.on('SIGTERM', shutdown);
    process.on('SIGINT', shutdown);

  } catch (error) {
    logger.error('Failed to start server:', error);
    process.exit(1);
  }
}

// Start the server
startServer().catch((err) => {
  logger.error('Error starting server:', err);
  process.exit(1);
});
